--- BlockFlowing.java
+++ BlockFlowing.java
@@ -1,11 +1,16 @@
-package net.minecraft.src;
+package net.minecraft.server;
 
 import java.util.Random;
 
+//LilyBukkit start
+import org.bukkit.block.BlockFace;
+import org.bukkit.event.block.BlockFromToEvent;
+//LilyBukkit end
+
 public class BlockFlowing extends BlockFluid {
     int numAdjacentSources;
     boolean[] isOptimalFlowDirection;
     int[] flowCost;
-    
+
     protected BlockFlowing(final int id, final Material material) {
         super(id, material);
@@ -14,5 +19,5 @@
         this.flowCost = new int[4];
     }
-    
+
     private void updateFlow(final World world, final int x, final int y, final int z) {
         final int i5 = world.getBlockMetadata(x, y, z);
@@ -21,7 +26,12 @@
         world.markBlockNeedsUpdate(x, y, z);
     }
-    
+
     @Override
     public void updateTick(final World world, final int x, final int y, final int z, final Random random) {
+        //LilyBukkit start
+        org.bukkit.World bworld = world.getWorld();
+        org.bukkit.Server server = world.getServer();
+        org.bukkit.block.Block source = bworld == null ? null : bworld.getBlockAt(x, y, z);
+        //LilyBukkit end
         int i6 = this.getFlowDecay(world, x, y, z);
         boolean z2 = true;
@@ -41,6 +51,5 @@
                 if (i9 >= 8) {
                     i8 = i9;
-                }
-                else {
+                } else {
                     i8 = i9 + 8;
                 }
@@ -49,10 +58,9 @@
                 if (world.isBlockNormalCube(x, y - 1, z)) {
                     i8 = 0;
-                }
-                else if (world.getBlockMaterial(x, y - 1, z) == this.material && world.getBlockMetadata(x, y, z) == 0) {
+                } else if (world.getBlockMaterial(x, y - 1, z) == this.material && world.getBlockMetadata(x, y, z) == 0) {
                     i8 = 0;
                 }
             }
-            if (this.material == Material.lava && i6 < 8 && i8 < 8 && i8 > i6 && random.nextInt(4) != 0) {
+            if (this.material == Material.lava && i8 < 8 && i8 > i6 && random.nextInt(4) != 0) {
                 i8 = i6;
                 z2 = false;
@@ -61,27 +69,31 @@
                 if ((i6 = i8) < 0) {
                     world.setBlockWithNotify(x, y, z, 0);
-                }
-                else {
+                } else {
                     world.setBlockMetadataWithNotify(x, y, z, i8);
                     world.scheduleBlockUpdate(x, y, z, this.blockID);
                     world.notifyBlocksOfNeighborChange(x, y, z, this.blockID);
                 }
-            }
-            else if (z2) {
+            } else if (z2) {
                 this.updateFlow(world, x, y, z);
             }
-        }
-        else {
+        } else {
             this.updateFlow(world, x, y, z);
         }
         if (this.liquidCanDisplaceBlock(world, x, y - 1, z)) {
-            if (i6 >= 8) {
-                world.setBlockAndMetadataWithNotify(x, y - 1, z, this.blockID, i6);
+            //LilyBukkit start - send "down" to the server
+            BlockFromToEvent event = new BlockFromToEvent(source, BlockFace.DOWN);
+            if (server != null) {
+                server.getPluginManager().callEvent(event);
             }
-            else {
-                world.setBlockAndMetadataWithNotify(x, y - 1, z, this.blockID, i6 + 8);
+
+            if (!event.isCancelled()) {
+                if (i6 >= 8) {
+                    world.setBlockAndMetadataWithNotify(x, y - 1, z, this.blockID, i6);
+                } else {
+                    world.setBlockAndMetadataWithNotify(x, y - 1, z, this.blockID, i6 + 8);
+                }
             }
-        }
-        else if (i6 >= 0 && (i6 == 0 || this.blockBlocksFlow(world, x, y - 1, z))) {
+            //LilyBukkit end
+        } else if (i6 >= 0 && (i6 == 0 || this.blockBlocksFlow(world, x, y - 1, z))) {
             final boolean[] z3 = this.getOptimalFlowDirections(world, x, y, z);
             int i8 = i6 + this.fluidType;
@@ -92,19 +104,26 @@
                 return;
             }
-            if (z3[0]) {
-                this.flowIntoBlock(world, x - 1, y, z, i8);
+
+            //LilyBukkit start - all four cardinal directions. Do not change the order!
+            BlockFace[] faces = new BlockFace[]{BlockFace.NORTH, BlockFace.SOUTH, BlockFace.EAST, BlockFace.WEST};
+            int index = 0;
+
+            for (BlockFace currentFace : faces) {
+                if (z3[index]) {
+                    BlockFromToEvent event = new BlockFromToEvent(source, currentFace);
+
+                    if (server != null) {
+                        server.getPluginManager().callEvent(event);
+                    }
+
+                    if (!event.isCancelled()) {
+                        this.flowIntoBlock(world, x + currentFace.getModX(), y, z + currentFace.getModZ(), i8);
+                    }
+                }
             }
-            if (z3[1]) {
-                this.flowIntoBlock(world, x + 1, y, z, i8);
-            }
-            if (z3[2]) {
-                this.flowIntoBlock(world, x, y, z - 1, i8);
-            }
-            if (z3[3]) {
-                this.flowIntoBlock(world, x, y, z + 1, i8);
-            }
+            //LilyBukkit end
         }
     }
-    
+
     private void flowIntoBlock(final World world, final int x, final int y, final int z, final int metadata) {
         if (this.liquidCanDisplaceBlock(world, x, y, z)) {
@@ -113,6 +132,5 @@
                 if (this.material == Material.lava) {
                     this.triggerLavaMixEffects(world, x, y, z);
-                }
-                else {
+                } else {
                     Block.blocksList[i6].dropBlockAsItem(world, x, y, z, world.getBlockMetadata(x, y, z));
                 }
@@ -121,5 +139,5 @@
         }
     }
-    
+
     private int calculateFlowCost(final World world, final int x, final int y, final int z, final int i5, final int i6) {
         int i7 = 1000;
@@ -155,5 +173,5 @@
         return i7;
     }
-    
+
     private boolean[] getOptimalFlowDirections(final World world, final int x, final int y, final int z) {
         for (int i5 = 0; i5 < 4; ++i5) {
@@ -176,6 +194,5 @@
                 if (!this.blockBlocksFlow(world, i6, y - 1, i7)) {
                     this.flowCost[i5] = 0;
-                }
-                else {
+                } else {
                     this.flowCost[i5] = this.calculateFlowCost(world, i6, y, i7, 1, i5);
                 }
@@ -193,8 +210,8 @@
         return this.isOptimalFlowDirection;
     }
-    
+
     private boolean blockBlocksFlow(final World world, final int x, final int y, final int z) {
         final int i5 = world.getBlockId(x, y, z);
-        if (i5 == Block.doorWood.blockID || i5 == Block.doorSteel.blockID || i5 == Block.signStanding.blockID || i5 == Block.ladder.blockID || i5 == Block.reed.blockID) {
+        if (i5 == Block.DOOR_WOOD.blockID || i5 == Block.DOOR_IRON.blockID || i5 == Block.SIGN_STANDING.blockID || i5 == Block.LADDER.blockID || i5 == Block.REED.blockID) {
             return true;
         }
@@ -205,5 +222,5 @@
         return material6.isSolid();
     }
-    
+
     protected int getSmallestFlowDecay(final World world, final int x, final int y, final int z, final int i5) {
         int i6 = this.getFlowDecay(world, x, y, z);
@@ -219,10 +236,10 @@
         return (i5 >= 0 && i6 >= i5) ? i5 : i6;
     }
-    
+
     private boolean liquidCanDisplaceBlock(final World world, final int x, final int y, final int z) {
         final Material material5 = world.getBlockMaterial(x, y, z);
         return material5 != this.material && material5 != Material.lava && !this.blockBlocksFlow(world, x, y, z);
     }
-    
+
     @Override
     public void onBlockAdded(final World world, final int x, final int y, final int z) {
