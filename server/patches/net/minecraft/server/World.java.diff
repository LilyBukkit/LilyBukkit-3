--- World.java
+++ World.java
@@ -1,6 +1,6 @@
-package net.minecraft.src;
+package net.minecraft.server;
 
 import java.io.DataInputStream;
-import java.util.Iterator;
+import java.nio.file.*;
 import java.util.Collection;
 import java.io.InputStream;
@@ -18,11 +18,28 @@
 import java.util.List;
 
+//LilyBukkit start
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.block.BlockCanBuildEvent;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.block.SnowFormEvent;
+import org.bukkit.event.block.BlockFormEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.bukkit.event.entity.ItemSpawnEvent;
+import org.bukkit.block.BlockState;
+//LilyBukkit end
+
 public class World implements IBlockAccess {
-    private List lightingToUpdate;
-    public List loadedEntityList;
-    private List unloadedEntityList;
-    private TreeSet scheduledTickTreeSet;
-    private Set scheduledTickSet;
-    public List loadedTileEntityList;
+    private List<MetadataChunkBlock> lightingToUpdate;
+    public List<Entity> loadedEntityList;
+    private List<Entity> unloadedEntityList;
+    private TreeSet<NextTickListEntry> scheduledTickTreeSet;
+    private Set<NextTickListEntry> scheduledTickSet;
+    public List<TileEntity> loadedTileEntityList;
     public long worldTime;
     public boolean snowCovered;
@@ -37,5 +54,5 @@
     private final long lockTimestamp;
     protected int autosavePeriod;
-    public List playerEntities;
+    public List<EntityPlayer> playerEntities;
     public int difficultySetting;
     public Random rand;
@@ -44,6 +61,6 @@
     public int spawnZ;
     public boolean isNewWorld;
-    protected List worldAccesses;
-    private IChunkProvider chunkProvider;
+    protected List<IWorldAccess> worldAccesses;
+    public IChunkProvider chunkProvider; //LilyBukkit - private -> public
     public File saveDirectory;
     public long randomSeed;
@@ -52,8 +69,8 @@
     public final String levelName;
     public boolean worldChunkLoadOverride;
-    private ArrayList collidingBoundingBoxes;
-    private Set positionsToUpdate;
+    private ArrayList<AxisAlignedBB> collidingBoundingBoxes;
+    private Set<ChunkCoordIntPair> positionsToUpdate;
     private int soundCounter;
-    private List entitiesWithinAABBExcludingEntity;
+    private List<Entity> entitiesWithinAABBExcludingEntity;
     public boolean multiplayerWorld;
     public long milestone;
@@ -66,5 +83,5 @@
     public long bossPeriod;
     private int numLightingUpdates;
-    
+
     static {
         World.lightBrightnessTable = new float[16];
@@ -75,5 +92,5 @@
         }
     }
-    
+
     public MobGiant SpawnGiant(final double x, final double y, final double z) {
         final MobGiant mobGiant7 = new MobGiant(this, (int)this.milestone);
@@ -82,12 +99,12 @@
         return mobGiant7;
     }
-    
+
     public void CueSpawnBossFrom(final int n, final int n2) {
     }
-    
+
     public World(final File worldFile, final String levelName) {
         this(worldFile, levelName, new Random().nextLong());
     }
-    
+
     public World(final String levelName) {
         this.milestone = 0L;
@@ -100,10 +117,10 @@
         this.bossPeriod = 10L;
         this.numLightingUpdates = 0;
-        this.lightingToUpdate = (List)new ArrayList();
-        this.loadedEntityList = (List)new ArrayList();
-        this.unloadedEntityList = (List)new ArrayList();
-        this.scheduledTickTreeSet = new TreeSet();
-        this.scheduledTickSet = (Set)new HashSet();
-        this.loadedTileEntityList = (List)new ArrayList();
+        this.lightingToUpdate = new ArrayList<>();
+        this.loadedEntityList = new ArrayList<>();
+        this.unloadedEntityList = new ArrayList<>();
+        this.scheduledTickTreeSet = new TreeSet<>();
+        this.scheduledTickSet = new HashSet<>();
+        this.loadedTileEntityList = new ArrayList<>();
         this.worldTime = 0L;
         this.snowCovered = false;
@@ -117,14 +134,14 @@
         this.lockTimestamp = System.currentTimeMillis();
         this.autosavePeriod = 40;
-        this.playerEntities = (List)new ArrayList();
+        this.playerEntities = new ArrayList<>();
         this.rand = new Random();
         this.isNewWorld = false;
-        this.worldAccesses = (List)new ArrayList();
+        this.worldAccesses = new ArrayList<>();
         this.randomSeed = 0L;
         this.sizeOnDisk = 0L;
-        this.collidingBoundingBoxes = new ArrayList();
-        this.positionsToUpdate = (Set)new HashSet();
+        this.collidingBoundingBoxes = new ArrayList<>();
+        this.positionsToUpdate = new HashSet<>();
         this.soundCounter = this.rand.nextInt(12000);
-        this.entitiesWithinAABBExcludingEntity = (List)new ArrayList();
+        this.entitiesWithinAABBExcludingEntity = new ArrayList<>();
         this.multiplayerWorld = false;
         this.levelName = levelName;
@@ -132,5 +149,5 @@
         this.calculateInitialSkylight();
     }
-    
+
     public World(final File baseDir, final String levelName, final long randomSeed) {
         this.milestone = 0L;
@@ -143,10 +160,10 @@
         this.bossPeriod = 10L;
         this.numLightingUpdates = 0;
-        this.lightingToUpdate = (List)new ArrayList();
-        this.loadedEntityList = (List)new ArrayList();
-        this.unloadedEntityList = (List)new ArrayList();
-        this.scheduledTickTreeSet = new TreeSet();
-        this.scheduledTickSet = (Set)new HashSet();
-        this.loadedTileEntityList = (List)new ArrayList();
+        this.lightingToUpdate = new ArrayList<>();
+        this.loadedEntityList = new ArrayList<>();
+        this.unloadedEntityList = new ArrayList<>();
+        this.scheduledTickTreeSet = new TreeSet<>();
+        this.scheduledTickSet = new HashSet<>();
+        this.loadedTileEntityList = new ArrayList<>();
         this.worldTime = 0L;
         this.snowCovered = false;
@@ -160,14 +177,14 @@
         this.lockTimestamp = System.currentTimeMillis();
         this.autosavePeriod = 40;
-        this.playerEntities = (List)new ArrayList();
+        this.playerEntities = new ArrayList<>();
         this.rand = new Random();
         this.isNewWorld = false;
-        this.worldAccesses = (List)new ArrayList();
+        this.worldAccesses = new ArrayList<>();
         this.randomSeed = 0L;
         this.sizeOnDisk = 0L;
-        this.collidingBoundingBoxes = new ArrayList();
-        this.positionsToUpdate = (Set)new HashSet();
+        this.collidingBoundingBoxes = new ArrayList<>();
+        this.positionsToUpdate = new HashSet<>();
         this.soundCounter = this.rand.nextInt(12000);
-        this.entitiesWithinAABBExcludingEntity = (List)new ArrayList();
+        this.entitiesWithinAABBExcludingEntity = new ArrayList<>();
         this.multiplayerWorld = false;
         this.levelName = levelName;
@@ -176,5 +193,5 @@
         try {
             final File file5 = new File(this.saveDirectory, "session.lock");
-            final DataOutputStream dataOutputStream6 = new DataOutputStream((OutputStream)new FileOutputStream(file5));
+            final DataOutputStream dataOutputStream6 = new DataOutputStream(Files.newOutputStream(file5.toPath()));
             try {
                 dataOutputStream6.writeLong(this.lockTimestamp);
@@ -192,5 +209,5 @@
         if (file5.exists()) {
             try {
-                final NBTTagCompound nBTTagCompound14 = CompressedStreamTools.readCompressed((InputStream)new FileInputStream(file5));
+                final NBTTagCompound nBTTagCompound14 = CompressedStreamTools.readCompressed(Files.newInputStream(file5.toPath()));
                 final NBTTagCompound nBTTagCompound15 = nBTTagCompound14.getCompoundTag("Data");
                 this.randomSeed = nBTTagCompound15.getLong("RandomSeed");
@@ -206,5 +223,5 @@
                 this.milestone = nBTTagCompound15.getLong("Milestones");
                 this.exclFrailMode = nBTTagCompound15.getBoolean("ExclusivelyFrail");
-                System.out.println(new StringBuilder("Current milestone: ").append(this.milestone).toString());
+                System.out.println("Current milestone: " + this.milestone);
             }
             catch (Exception exception11) {
@@ -234,14 +251,14 @@
         this.calculateInitialSkylight();
     }
-    
+
     protected IChunkProvider getChunkProvider(final File saveDir) {
         return new ChunkProviderLoadOrGenerate(this, new ChunkLoader(saveDir, true), new ChunkProviderGenerate(this, this.randomSeed));
     }
-    
+
     private boolean findSpawn(final int x, final int z) {
         final int i3 = this.getFirstUncoveredBlock(x, z);
-        return i3 == Block.sand.blockID;
+        return i3 == Block.SAND.blockID;
     }
-    
+
     private int getFirstUncoveredBlock(final int x, final int z) {
         int i3;
@@ -249,5 +266,5 @@
         return this.getBlockId(x, i3, z);
     }
-    
+
     public void saveWorld(final boolean flag, final IProgressUpdate progressUpdate) {
         if (this.chunkProvider.canSave()) {
@@ -262,5 +279,5 @@
         }
     }
-    
+
     private void saveLevel() {
         this.checkSessionLock();
@@ -278,5 +295,5 @@
         EntityPlayer entityPlayer2 = null;
         if (this.playerEntities.size() > 0) {
-            entityPlayer2 = (EntityPlayer)this.playerEntities.get(0);
+            entityPlayer2 = this.playerEntities.get(0);
         }
         if (entityPlayer2 != null) {
@@ -286,10 +303,10 @@
         }
         final NBTTagCompound nBTTagCompound2 = new NBTTagCompound();
-        nBTTagCompound2.setTag("Data", (NBTBase)nBTTagCompound1);
+        nBTTagCompound2.setTag("Data", nBTTagCompound1);
         try {
             final File file4 = new File(this.saveDirectory, "level.dat_new");
             final File file5 = new File(this.saveDirectory, "level.dat_old");
             final File file6 = new File(this.saveDirectory, "level.dat");
-            CompressedStreamTools.writeCompressed(nBTTagCompound2, (OutputStream)new FileOutputStream(file4));
+            CompressedStreamTools.writeCompressed(nBTTagCompound2, Files.newOutputStream(file4.toPath()));
             if (file5.exists()) {
                 file5.delete();
@@ -308,13 +325,13 @@
         }
     }
-    
+
     public int getBlockId(final int blockX, final int blockY, final int blockZ) {
         return (blockX >= -32000000 && blockZ >= -32000000 && blockX < 32000000 && blockZ <= 32000000) ? ((blockY < 0) ? 0 : ((blockY >= 128) ? 0 : this.getChunkFromChunkCoords(blockX >> 4, blockZ >> 4).getBlockID(blockX & 0xF, blockY, blockZ & 0xF))) : 0;
     }
-    
+
     public boolean blockExists(final int x, final int y, final int z) {
         return y >= 0 && y < 128 && this.chunkExists(x >> 4, z >> 4);
     }
-    
+
     public boolean checkChunksExist(int i1, int i2, int i3, int i4, int i5, int i6) {
         if (i5 >= 0 && i2 < 128) {
@@ -336,17 +353,17 @@
         return false;
     }
-    
+
     private boolean chunkExists(final int x, final int z) {
         return this.chunkProvider.chunkExists(x, z);
     }
-    
+
     public Chunk getChunkFromBlockCoords(final int x, final int z) {
         return this.getChunkFromChunkCoords(x >> 4, z >> 4);
     }
-    
+
     public Chunk getChunkFromChunkCoords(final int x, final int z) {
         return this.chunkProvider.provideChunk(x, z);
     }
-    
+
     public boolean setBlockAndMetadata(final int x, final int y, final int z, final int i4, final int i5) {
         if (x < -32000000 || z < -32000000 || x >= 32000000 || z > 32000000) {
@@ -362,5 +379,5 @@
         return chunk6.setBlockIDWithMetadata(x & 0xF, y, z & 0xF, i4, i5);
     }
-    
+
     public boolean setBlock(final int x, final int y, final int z, final int i4) {
         if (x < -32000000 || z < -32000000 || x >= 32000000 || z > 32000000) {
@@ -376,10 +393,10 @@
         return chunk5.setBlockID(x & 0xF, y, z & 0xF, i4);
     }
-    
+
     public Material getBlockMaterial(final int x, final int y, final int z) {
         final int i4 = this.getBlockId(x, y, z);
         return (i4 == 0) ? Material.air : Block.blocksList[i4].material;
     }
-    
+
     public int getBlockMetadata(int x, final int y, int z) {
         if (x < -32000000 || z < -32000000 || x >= 32000000 || z > 32000000) {
@@ -397,9 +414,9 @@
         return chunk4.getBlockMetadata(x, y, z);
     }
-    
+
     public void setBlockMetadataWithNotify(final int i1, final int i2, final int i3, final int i4) {
         this.setBlockMetadata(i1, i2, i3, i4);
     }
-    
+
     public boolean setBlockMetadata(int x, final int y, int z, final int i4) {
         if (x < -32000000 || z < -32000000 || x >= 32000000 || z > 32000000) {
@@ -418,5 +435,5 @@
         return true;
     }
-    
+
     public boolean setBlockWithNotify(final int x, final int y, final int z, final int i4) {
         if (this.setBlock(x, y, z, i4)) {
@@ -426,5 +443,5 @@
         return false;
     }
-    
+
     public boolean setBlockAndMetadataWithNotify(final int x, final int y, final int z, final int i4, final int i5) {
         if (this.setBlockAndMetadata(x, y, z, i4, i5)) {
@@ -434,16 +451,16 @@
         return false;
     }
-    
+
     public void markBlockNeedsUpdate(final int x, final int y, final int z) {
-        for (int i4 = 0; i4 < this.worldAccesses.size(); ++i4) {
-            ((IWorldAccess)this.worldAccesses.get(i4)).markBlockAndNeighborsNeedsUpdate(x, y, z);
+        for (IWorldAccess worldAccess : this.worldAccesses) {
+            worldAccess.markBlockAndNeighborsNeedsUpdate(x, y, z);
         }
     }
-    
+
     protected void notifyBlockChange(final int x, final int y, final int z, final int i4) {
         this.markBlockNeedsUpdate(x, y, z);
         this.notifyBlocksOfNeighborChange(x, y, z, i4);
     }
-    
+
     public void markBlocksDirtyVertical(final int x, final int z, int y, int i4) {
         if (y > i4) {
@@ -454,11 +471,11 @@
         this.markBlocksDirty(x, y, z, x, i4, z);
     }
-    
+
     public void markBlocksDirty(final int i1, final int i2, final int i3, final int i4, final int i5, final int i6) {
-        for (int i7 = 0; i7 < this.worldAccesses.size(); ++i7) {
-            ((IWorldAccess)this.worldAccesses.get(i7)).markBlockRangeNeedsUpdate(i1, i2, i3, i4, i5, i6);
+        for (IWorldAccess worldAccess : this.worldAccesses) {
+            worldAccess.markBlockRangeNeedsUpdate(i1, i2, i3, i4, i5, i6);
         }
     }
-    
+
     public void notifyBlocksOfNeighborChange(final int x, final int y, final int z, final int i4) {
         this.notifyBlockOfNeighborChange(x - 1, y, z, i4);
@@ -469,5 +486,5 @@
         this.notifyBlockOfNeighborChange(x, y, z + 1, i4);
     }
-    
+
     private void notifyBlockOfNeighborChange(final int x, final int y, final int z, final int i4) {
         if (!this.editingBlocks && !this.multiplayerWorld) {
@@ -478,13 +495,13 @@
         }
     }
-    
+
     public boolean canBlockSeeTheSky(final int x, final int y, final int z) {
         return this.getChunkFromChunkCoords(x >> 4, z >> 4).canBlockSeeTheSky(x & 0xF, y, z & 0xF);
     }
-    
+
     public int getBlockLightValue(final int x, final int y, final int z) {
         return this.getBlockLightValue_do(x, y, z, true);
     }
-    
+
     public int getBlockLightValue_do(int x, final int y, int z, final boolean z4) {
         if (x < -32000000 || z < -32000000 || x >= 32000000 || z > 32000000) {
@@ -493,5 +510,5 @@
         if (z4) {
             final int i5 = this.getBlockId(x, y, z);
-            if (i5 == Block.stairSingle.blockID || i5 == Block.tilledField.blockID) {
+            if (i5 == Block.STAIR_SINGLE.blockID || i5 == Block.TILLED_FIELD.blockID) {
                 int i6 = this.getBlockLightValue_do(x, y + 1, z, false);
                 final int i7 = this.getBlockLightValue_do(x + 1, y, z, false);
@@ -529,5 +546,5 @@
         return chunk11.getBlockLightValue(x, y, z, this.skylightSubtracted);
     }
-    
+
     public boolean canExistingBlockSeeTheSky(int x, final int y, int z) {
         if (x < -32000000 || z < -32000000 || x >= 32000000 || z > 32000000) {
@@ -548,5 +565,5 @@
         return chunk4.canBlockSeeTheSky(x, y, z);
     }
-    
+
     public int getHeightValue(final int blockX, final int blockZ) {
         if (blockX < -32000000 || blockZ < -32000000 || blockX >= 32000000 || blockZ > 32000000) {
@@ -559,5 +576,5 @@
         return chunk3.getHeightValue(blockX & 0xF, blockZ & 0xF);
     }
-    
+
     public void neighborLightPropagationChanged(final EnumSkyBlock skyBlock, final int x, final int y, final int z, int i5) {
         if (this.blockExists(x, y, z)) {
@@ -578,5 +595,5 @@
         }
     }
-    
+
     public int getSavedLightValue(final EnumSkyBlock skyBlock, final int blockX, final int blockY, final int blockZ) {
         if (blockY < 0 || blockY >= 128 || blockX < -32000000 || blockZ < -32000000 || blockX >= 32000000 || blockZ > 32000000) {
@@ -591,27 +608,27 @@
         return chunk7.getSavedLightValue(skyBlock, blockX & 0xF, blockY, blockZ & 0xF);
     }
-    
+
     public void setLightValue(final EnumSkyBlock skyBlock, final int blockX, final int blockY, final int blockZ, final int i5) {
         if (blockX >= -32000000 && blockZ >= -32000000 && blockX < 32000000 && blockZ <= 32000000 && blockY >= 0 && blockY < 128 && this.chunkExists(blockX >> 4, blockZ >> 4)) {
             final Chunk chunk6 = this.getChunkFromChunkCoords(blockX >> 4, blockZ >> 4);
             chunk6.setLightValue(skyBlock, blockX & 0xF, blockY, blockZ & 0xF, i5);
-            for (int i6 = 0; i6 < this.worldAccesses.size(); ++i6) {
-                ((IWorldAccess)this.worldAccesses.get(i6)).markBlockAndNeighborsNeedsUpdate(blockX, blockY, blockZ);
+            for (IWorldAccess worldAccess : this.worldAccesses) {
+                worldAccess.markBlockAndNeighborsNeedsUpdate(blockX, blockY, blockZ);
             }
         }
     }
-    
+
     public float getBrightness(final int x, final int y, final int z) {
         return World.lightBrightnessTable[this.getBlockLightValue(x, y, z)];
     }
-    
+
     public boolean isDaytime() {
         return this.skylightSubtracted < 4;
     }
-    
+
     public MovingObjectPosition rayTraceBlocks(final Vec3D vector1, final Vec3D vector2) {
         return this.rayTraceBlocks_do(vector1, vector2, false);
     }
-    
+
     public MovingObjectPosition rayTraceBlocks_do(final Vec3D vector1, final Vec3D vector2, final boolean z3) {
         if (Double.isNaN(vector1.xCoord) || Double.isNaN(vector1.yCoord) || Double.isNaN(vector1.zCoord)) {
@@ -669,5 +686,4 @@
                     d16 = (d13 - vector1.zCoord) / d19;
                 }
-                final boolean z4 = false;
                 byte b35;
                 if (d14 < d15 && d14 < d16) {
@@ -711,24 +727,19 @@
                 if (b35 == 5) {
                     --i7;
-                    final Vec3D vec3D31 = vec3D30;
-                    ++vec3D31.xCoord;
+                    ++vec3D30.xCoord;
                 }
-                final Vec3D vec3D32 = vec3D30;
                 final double yCoord = MathHelper.floor_double(vector1.yCoord);
-                vec3D32.yCoord = yCoord;
+                vec3D30.yCoord = yCoord;
                 i8 = (int)yCoord;
                 if (b35 == 1) {
                     --i8;
-                    final Vec3D vec3D33 = vec3D30;
-                    ++vec3D33.yCoord;
+                    ++vec3D30.yCoord;
                 }
-                final Vec3D vec3D34 = vec3D30;
                 final double zCoord = MathHelper.floor_double(vector1.zCoord);
-                vec3D34.zCoord = zCoord;
+                vec3D30.zCoord = zCoord;
                 i9 = (int)zCoord;
                 if (b35 == 3) {
                     --i9;
-                    final Vec3D vec3D35 = vec3D30;
-                    ++vec3D35.zCoord;
+                    ++vec3D30.zCoord;
                 }
                 final int i11 = this.getBlockId(i7, i8, i9);
@@ -747,36 +758,43 @@
         return null;
     }
-    
+
+    public Entity getEntityWithId(int id) {
+        for (Entity entity : loadedEntityList) {
+            if (entity.entityID == id) return entity;
+        }
+        for (Entity entity : unloadedEntityList) {
+            if (entity.entityID == id) return entity;
+        }
+        return null;
+    }
+
     public void playSoundAtEntity(final Entity entity, final String soundName, final float f3, final float f4) {
-        for (int i5 = 0; i5 < this.worldAccesses.size(); ++i5) {
-            ((IWorldAccess)this.worldAccesses.get(i5)).playSound(soundName, entity.posX, entity.posY - entity.yOffset, entity.posZ, f3, f4);
+        for (IWorldAccess worldAccess : this.worldAccesses) {
+            worldAccess.playSound(soundName, entity.posX, entity.posY - entity.yOffset, entity.posZ, f3, f4);
         }
     }
-    
+
     public void playSoundEffect(final double x, final double y, final double z, final String soundName, final float f8, final float f9) {
-        for (int i10 = 0; i10 < this.worldAccesses.size(); ++i10) {
-            ((IWorldAccess)this.worldAccesses.get(i10)).playSound(soundName, x, y, z, f8, f9);
+        for (IWorldAccess worldAccess : this.worldAccesses) {
+            worldAccess.playSound(soundName, x, y, z, f8, f9);
         }
     }
-    
+
     public void playRecord(final String recordName, final int x, final int y, final int z) {
-        for (int i5 = 0; i5 < this.worldAccesses.size(); ++i5) {
-            ((IWorldAccess)this.worldAccesses.get(i5)).playRecord(recordName, x, y, z);
+        for (IWorldAccess worldAccess : this.worldAccesses) {
+            worldAccess.playRecord(recordName, x, y, z);
         }
     }
-    
+
     public void spawnParticle(final String particleName, final double x, final double y, final double z, final double d8, final double d10, final double d12) {
-        for (int i14 = 0; i14 < this.worldAccesses.size(); ++i14) {
-            ((IWorldAccess)this.worldAccesses.get(i14)).spawnParticle(particleName, x, y, z, d8, d10, d12);
+        for (IWorldAccess worldAccess : this.worldAccesses) {
+            worldAccess.spawnParticle(particleName, x, y, z, d8, d10, d12);
         }
     }
-    
+
     public boolean spawnEntityInWorld(final Entity entity) {
         final int i2 = MathHelper.floor_double(entity.posX / 16.0);
         final int i3 = MathHelper.floor_double(entity.posZ / 16.0);
-        boolean z4 = false;
-        if (entity instanceof EntityPlayer) {
-            z4 = true;
-        }
+        boolean z4 = entity instanceof EntityPlayer;
         if (!z4 && !this.chunkExists(i2, i3)) {
             return false;
@@ -784,5 +802,5 @@
         if (entity instanceof EntityPlayer) {
             this.playerEntities.add(entity);
-            System.out.println(new StringBuilder("Player count: ").append(this.playerEntities.size()).toString());
+            System.out.println("Player count: " + this.playerEntities.size());
         }
         this.getChunkFromChunkCoords(i2, i3).addEntity(entity);
@@ -791,44 +809,44 @@
         return true;
     }
-    
+
     protected void obtainEntitySkin(final Entity entity) {
-        for (int i2 = 0; i2 < this.worldAccesses.size(); ++i2) {
-            ((IWorldAccess)this.worldAccesses.get(i2)).obtainEntitySkin(entity);
+        for (IWorldAccess worldAccess : this.worldAccesses) {
+            worldAccess.obtainEntitySkin(entity);
         }
     }
-    
+
     protected void releaseEntitySkin(final Entity entity) {
-        for (int i2 = 0; i2 < this.worldAccesses.size(); ++i2) {
-            ((IWorldAccess)this.worldAccesses.get(i2)).releaseEntitySkin(entity);
+        for (IWorldAccess worldAccess : this.worldAccesses) {
+            worldAccess.releaseEntitySkin(entity);
         }
     }
-    
+
     public void setEntityDead(final Entity entity) {
         entity.setEntityDead();
         if (entity instanceof EntityPlayer) {
             this.playerEntities.remove(entity);
-            System.out.println(new StringBuilder("Player count: ").append(this.playerEntities.size()).toString());
+            System.out.println("Player count: " + this.playerEntities.size());
         }
     }
-    
+
     public void addWorldAccess(final IWorldAccess worldAccess) {
         this.worldAccesses.add(worldAccess);
     }
-    
-    public List getCollidingBoundingBoxes(final Entity entity, final AxisAlignedBB aabb) {
+
+    public List<AxisAlignedBB> getCollidingBoundingBoxes(final Entity entity, final AxisAlignedBB aabb) {
         this.collidingBoundingBoxes.clear();
-        final int i3 = MathHelper.floor_double(aabb.minX);
-        final int i4 = MathHelper.floor_double(aabb.maxX + 1.0);
-        final int i5 = MathHelper.floor_double(aabb.minY);
-        final int i6 = MathHelper.floor_double(aabb.maxY + 1.0);
-        final int i7 = MathHelper.floor_double(aabb.minZ);
-        final int i8 = MathHelper.floor_double(aabb.maxZ + 1.0);
-        for (int i9 = i3; i9 < i4; ++i9) {
-            for (int i10 = i7; i10 < i8; ++i10) {
-                if (this.blockExists(i9, 64, i10)) {
-                    for (int i11 = i5 - 1; i11 < i6; ++i11) {
-                        final Block block12 = Block.blocksList[this.getBlockId(i9, i11, i10)];
-                        if (block12 != null) {
-                            block12.getCollidingBoundingBoxes(this, i9, i11, i10, aabb, this.collidingBoundingBoxes);
+        final int minX = MathHelper.floor_double(aabb.minX);
+        final int maxX = MathHelper.floor_double(aabb.maxX + 1.0);
+        final int minY = MathHelper.floor_double(aabb.minY);
+        final int maxY = MathHelper.floor_double(aabb.maxY + 1.0);
+        final int minZ = MathHelper.floor_double(aabb.minZ);
+        final int maxZ = MathHelper.floor_double(aabb.maxZ + 1.0);
+        for (int i = minX; i < maxX; ++i) {
+            for (int j = minZ; j < maxZ; ++j) {
+                if (this.blockExists(i, 64, j)) {
+                    for (int k = minY - 1; k < maxY; ++k) {
+                        final Block block = Block.blocksList[this.getBlockId(i, k, j)];
+                        if (block != null) {
+                            block.getCollidingBoundingBoxes(this, i, k, j, aabb, this.collidingBoundingBoxes);
                         }
                     }
@@ -837,18 +855,18 @@
         }
         final double d14 = 0.25;
-        final List list15 = this.getEntitiesWithinAABBExcludingEntity(entity, aabb.expand(d14, d14, d14));
-        for (int i12 = 0; i12 < list15.size(); ++i12) {
-            AxisAlignedBB axisAlignedBB13 = ((Entity)list15.get(i12)).getBoundingBox();
+        final List<Entity> list15 = this.getEntitiesWithinAABBExcludingEntity(entity, aabb.expand(d14, d14, d14));
+        for (Entity value : list15) {
+            AxisAlignedBB axisAlignedBB13 = value.getBoundingBox();
             if (axisAlignedBB13 != null && axisAlignedBB13.intersectsWith(aabb)) {
                 this.collidingBoundingBoxes.add(axisAlignedBB13);
             }
-            axisAlignedBB13 = entity.getCollisionBox((Entity)list15.get(i12));
+            axisAlignedBB13 = entity.getCollisionBox(value);
             if (axisAlignedBB13 != null && axisAlignedBB13.intersectsWith(aabb)) {
                 this.collidingBoundingBoxes.add(axisAlignedBB13);
             }
         }
-        return (List)this.collidingBoundingBoxes;
+        return this.collidingBoundingBoxes;
     }
-    
+
     public int calculateSkylightSubtracted(final float f1) {
         final float f2 = this.getCelestialAngle(f1);
@@ -862,5 +880,5 @@
         return (int)(f3 * 11.0f);
     }
-    
+
     public float getCelestialAngle(final float f1) {
         final int i2 = (int)(this.worldTime % 24000L);
@@ -877,5 +895,5 @@
         return f2;
     }
-    
+
     public int getTopSolidOrLiquidBlock(int x, int z) {
         final Chunk chunk3 = this.getChunkFromBlockCoords(x, z);
@@ -892,5 +910,5 @@
         return -1;
     }
-    
+
     public void scheduleBlockUpdate(final int i1, final int i2, final int i3, final int i4) {
         final NextTickListEntry nextTickListEntry5 = new NextTickListEntry(i1, i2, i3, i4);
@@ -906,9 +924,8 @@
         }
     }
-    
+
     public void updateEntities() {
-        this.loadedEntityList.removeAll((Collection)this.unloadedEntityList);
-        for (int i1 = 0; i1 < this.unloadedEntityList.size(); ++i1) {
-            final Entity entity2 = (Entity)this.unloadedEntityList.get(i1);
+        this.loadedEntityList.removeAll(this.unloadedEntityList);
+        for (final Entity entity2 : this.unloadedEntityList) {
             final int i2 = entity2.chunkCoordX;
             final int i3 = entity2.chunkCoordZ;
@@ -917,10 +934,10 @@
             }
         }
-        for (int i1 = 0; i1 < this.unloadedEntityList.size(); ++i1) {
-            this.releaseEntitySkin((Entity)this.unloadedEntityList.get(i1));
+        for (Entity entity : this.unloadedEntityList) {
+            this.releaseEntitySkin(entity);
         }
         this.unloadedEntityList.clear();
         for (int i1 = 0; i1 < this.loadedEntityList.size(); ++i1) {
-            final Entity entity2 = (Entity)this.loadedEntityList.get(i1);
+            final Entity entity2 = this.loadedEntityList.get(i1);
             if (entity2.ridingEntity != null) {
                 if (!entity2.ridingEntity.isDead && entity2.ridingEntity.riddenByEntity == entity2) {
@@ -943,10 +960,9 @@
             }
         }
-        for (int i1 = 0; i1 < this.loadedTileEntityList.size(); ++i1) {
-            final TileEntity tileEntity5 = (TileEntity)this.loadedTileEntityList.get(i1);
+        for (final TileEntity tileEntity5 : this.loadedTileEntityList) {
             tileEntity5.updateEntity();
         }
     }
-    
+
     protected void updateEntity(final Entity entity) {
         final int i2 = MathHelper.floor_double(entity.posX);
@@ -999,17 +1015,16 @@
                 entity.posZ = entity.lastTickPosZ;
             }
-            if (Double.isNaN((double)entity.rotationPitch) || Double.isInfinite((double)entity.rotationPitch)) {
+            if (Double.isNaN(entity.rotationPitch) || Double.isInfinite(entity.rotationPitch)) {
                 entity.rotationPitch = entity.prevRotationPitch;
             }
-            if (Double.isNaN((double)entity.rotationYaw) || Double.isInfinite((double)entity.rotationYaw)) {
+            if (Double.isNaN(entity.rotationYaw) || Double.isInfinite(entity.rotationYaw)) {
                 entity.rotationYaw = entity.prevRotationYaw;
             }
         }
     }
-    
+
     public boolean checkIfAABBIsClear(final AxisAlignedBB aabb) {
-        final List list2 = this.getEntitiesWithinAABBExcludingEntity(null, aabb);
-        for (int i3 = 0; i3 < list2.size(); ++i3) {
-            final Entity entity4 = (Entity)list2.get(i3);
+        final List<Entity> list2 = this.getEntitiesWithinAABBExcludingEntity(null, aabb);
+        for (Entity entity4 : list2) {
             if (!entity4.isDead && entity4.preventEntitySpawning) {
                 return false;
@@ -1018,5 +1033,5 @@
         return true;
     }
-    
+
     public boolean getIsAnyLiquid(final AxisAlignedBB aabb) {
         int i2 = MathHelper.floor_double(aabb.minX);
@@ -1047,5 +1062,5 @@
         return false;
     }
-    
+
     public boolean isBoundingBoxBurning(final AxisAlignedBB aabb) {
         final int i2 = MathHelper.floor_double(aabb.minX);
@@ -1059,5 +1074,5 @@
                 for (int i10 = i6; i10 < i7; ++i10) {
                     final int i11 = this.getBlockId(i8, i9, i10);
-                    if (i11 == Block.fire.blockID || i11 == Block.lavaMoving.blockID || i11 == Block.lavaStill.blockID) {
+                    if (i11 == Block.FIRE.blockID || i11 == Block.LAVA_MOVING.blockID || i11 == Block.LAVA_STILL.blockID) {
                         return true;
                     }
@@ -1067,5 +1082,5 @@
         return false;
     }
-    
+
     public boolean handleMaterialAcceleration(final AxisAlignedBB aabb, final Material material, final Entity entity) {
         final int i4 = MathHelper.floor_double(aabb.minX);
@@ -1100,5 +1115,5 @@
         return z10;
     }
-    
+
     public boolean isMaterialInBB(final AxisAlignedBB aabb, final Material material) {
         final int i3 = MathHelper.floor_double(aabb.minX);
@@ -1120,5 +1135,5 @@
         return false;
     }
-    
+
     public boolean isAABBInMaterial(final AxisAlignedBB aabb, final Material material) {
         final int i3 = MathHelper.floor_double(aabb.minX);
@@ -1147,9 +1162,9 @@
         return false;
     }
-    
+
     public void createExplosion(final Entity entity, final double x, final double y, final double z, final float f8) {
         new Explosion().doExplosion(this, entity, x, y, z, f8);
     }
-    
+
     public float getBlockDensity(final Vec3D vector, final AxisAlignedBB aabb) {
         final double d3 = 1.0 / ((aabb.maxX - aabb.minX) * 2.0 + 1.0);
@@ -1173,10 +1188,10 @@
         return i9 / (float)i10;
     }
-    
+
     public TileEntity getBlockTileEntity(final int x, final int y, final int z) {
         final Chunk chunk4 = this.getChunkFromChunkCoords(x >> 4, z >> 4);
         return (chunk4 != null) ? chunk4.getChunkBlockTileEntity(x & 0xF, y, z & 0xF) : null;
     }
-    
+
     public void setBlockTileEntity(final int x, final int y, final int z, final TileEntity tileEntity) {
         final Chunk chunk5 = this.getChunkFromChunkCoords(x >> 4, z >> 4);
@@ -1185,5 +1200,5 @@
         }
     }
-    
+
     public void removeBlockTileEntity(final int x, final int y, final int z) {
         final Chunk chunk4 = this.getChunkFromChunkCoords(x >> 4, z >> 4);
@@ -1192,10 +1207,10 @@
         }
     }
-    
+
     public boolean isBlockNormalCube(final int x, final int y, final int z) {
         final Block block4 = Block.blocksList[this.getBlockId(x, y, z)];
         return block4 != null && block4.isOpaqueCube();
     }
-    
+
     public boolean updatingLighting() {
         ++this.numLightingUpdates;
@@ -1210,13 +1225,13 @@
                 return true;
             }
-            ((MetadataChunkBlock)this.lightingToUpdate.remove(this.lightingToUpdate.size() - 1)).updateLight(this);
+            this.lightingToUpdate.remove(this.lightingToUpdate.size() - 1).updateLight(this);
         }
         return false;
     }
-    
+
     public void scheduleLightingUpdate(final EnumSkyBlock skyBlock, final int i2, final int i3, final int i4, final int i5, final int i6, final int i7) {
         this.scheduleLightingUpdate_do(skyBlock, i2, i3, i4, i5, i6, i7, true);
     }
-    
+
     public void scheduleLightingUpdate_do(final EnumSkyBlock skyBlock, final int i2, final int i3, final int i4, final int i5, final int i6, final int i7, final boolean z8) {
         final int i8 = (i5 + i2) / 2;
@@ -1230,5 +1245,5 @@
                 }
                 for (int i12 = 0; i12 < i11; ++i12) {
-                    final MetadataChunkBlock metadataChunkBlock14 = (MetadataChunkBlock)this.lightingToUpdate.get(this.lightingToUpdate.size() - i12 - 1);
+                    final MetadataChunkBlock metadataChunkBlock14 = this.lightingToUpdate.get(this.lightingToUpdate.size() - i12 - 1);
                     if (metadataChunkBlock14.skyBlock == skyBlock && metadataChunkBlock14.getLightUpdated(i2, i3, i4, i5, i6, i7)) {
                         return;
@@ -1244,5 +1259,5 @@
         }
     }
-    
+
     public void calculateInitialSkylight() {
         final int i1 = this.calculateSkylightSubtracted(1.0f);
@@ -1251,5 +1266,5 @@
         }
     }
-    
+
     public void tick() {
         this.numLightingUpdates = 0;
@@ -1258,6 +1273,6 @@
         if (i1 != this.skylightSubtracted) {
             this.skylightSubtracted = i1;
-            for (int i2 = 0; i2 < this.worldAccesses.size(); ++i2) {
-                ((IWorldAccess)this.worldAccesses.get(i2)).updateAllRenderers();
+            for (IWorldAccess worldAccess : this.worldAccesses) {
+                worldAccess.updateAllRenderers();
             }
         }
@@ -1277,5 +1292,5 @@
         if (this.worldTime % 23000L == 0L) {
             ++this.milestone;
-            System.out.println(new StringBuilder("Milestone ").append(this.milestone).append(this.exclFrailMode ? "*" : "").append(" reached.").toString());
+            System.out.println("Milestone " + this.milestone + (this.exclFrailMode ? "*" : "") + " reached.");
         }
         if (this.worldTime % this.autosavePeriod == 0L) {
@@ -1285,11 +1300,10 @@
         this.updateBlocksAndPlayCaveSounds();
     }
-    
+
     protected void updateBlocksAndPlayCaveSounds() {
         this.positionsToUpdate.clear();
-        for (int i1 = 0; i1 < this.playerEntities.size(); ++i1) {
-            final EntityPlayer entityPlayer2 = (EntityPlayer)this.playerEntities.get(i1);
-            final int i2 = MathHelper.floor_double(entityPlayer2.posX / 16.0);
-            final int i3 = MathHelper.floor_double(entityPlayer2.posZ / 16.0);
+        for (EntityPlayer playerEntity : this.playerEntities) {
+            final int i2 = MathHelper.floor_double(playerEntity.posX / 16.0);
+            final int i3 = MathHelper.floor_double(playerEntity.posZ / 16.0);
             final byte b5 = 9;
             for (int i4 = -b5; i4 <= b5; ++i4) {
@@ -1331,9 +1345,9 @@
                 if (i7 >= 0 && i7 < 128 && chunk14.getSavedLightValue(EnumSkyBlock.Block, i5, i7, i6) < 10) {
                     final int i8 = chunk14.getBlockID(i5, i7 - 1, i6);
-                    if (chunk14.getBlockID(i5, i7, i6) == 0 && Block.snow.canPlaceBlockAt(this, i5 + i2, i7, i6 + i3)) {
-                        this.setBlockWithNotify(i5 + i2, i7, i6 + i3, Block.snow.blockID);
+                    if (chunk14.getBlockID(i5, i7, i6) == 0 && Block.SNOW.canPlaceBlockAt(this, i5 + i2, i7, i6 + i3)) {
+                        this.setBlockWithNotify(i5 + i2, i7, i6 + i3, Block.SNOW.blockID);
                     }
-                    if (i8 == Block.waterStill.blockID && chunk14.getBlockMetadata(i5, i7 - 1, i6) == 0) {
-                        this.setBlockWithNotify(i5 + i2, i7 - 1, i6 + i3, Block.ice.blockID);
+                    if (i8 == Block.WATER_STILL.blockID && chunk14.getBlockMetadata(i5, i7 - 1, i6) == 0) {
+                        this.setBlockWithNotify(i5 + i2, i7 - 1, i6 + i3, Block.ICE.blockID);
                     }
                 }
@@ -1352,5 +1366,5 @@
         }
     }
-    
+
     public boolean tickUpdates(final boolean z1) {
         int i2 = this.scheduledTickTreeSet.size();
@@ -1362,5 +1376,5 @@
         }
         for (int i3 = 0; i3 < i2; ++i3) {
-            final NextTickListEntry nextTickListEntry4 = (NextTickListEntry)this.scheduledTickTreeSet.first();
+            final NextTickListEntry nextTickListEntry4 = this.scheduledTickTreeSet.first();
             if (!z1 && nextTickListEntry4.scheduledTime > this.worldTime) {
                 break;
@@ -1378,6 +1392,6 @@
         return this.scheduledTickTreeSet.size() != 0;
     }
-    
-    public List getEntitiesWithinAABBExcludingEntity(final Entity entity, final AxisAlignedBB aabb) {
+
+    public List<Entity> getEntitiesWithinAABBExcludingEntity(final Entity entity, final AxisAlignedBB aabb) {
         this.entitiesWithinAABBExcludingEntity.clear();
         final int i3 = MathHelper.floor_double((aabb.minX - 2.0) / 16.0);
@@ -1394,34 +1408,33 @@
         return this.entitiesWithinAABBExcludingEntity;
     }
-    
-    public List getEntitiesWithinAABB(final Class clazz, final AxisAlignedBB aabb) {
+
+    public List<Entity> getEntitiesWithinAABB(final Class<? extends Entity> clazz, final AxisAlignedBB aabb) {
         final int i3 = MathHelper.floor_double((aabb.minX - 2.0) / 16.0);
         final int i4 = MathHelper.floor_double((aabb.maxX + 2.0) / 16.0);
         final int i5 = MathHelper.floor_double((aabb.minZ - 2.0) / 16.0);
         final int i6 = MathHelper.floor_double((aabb.maxZ + 2.0) / 16.0);
-        final ArrayList arrayList7 = new ArrayList();
+        final ArrayList<Entity> arrayList7 = new ArrayList<>();
         for (int i7 = i3; i7 <= i4; ++i7) {
             for (int i8 = i5; i8 <= i6; ++i8) {
                 if (this.chunkExists(i7, i8)) {
-                    this.getChunkFromChunkCoords(i7, i8).getEntitiesOfTypeWithinAAAB(clazz, aabb, (List)arrayList7);
+                    this.getChunkFromChunkCoords(i7, i8).getEntitiesOfTypeWithinAAAB(clazz, aabb, arrayList7);
                 }
             }
         }
-        return (List)arrayList7;
+        return arrayList7;
     }
-    
+
     public void updateTileEntityChunkAndDoNothing(final int x, final int y, final int z, final TileEntity tileEntity) {
         if (this.blockExists(x, y, z)) {
             this.getChunkFromBlockCoords(x, z).setChunkModified();
         }
-        for (int i5 = 0; i5 < this.worldAccesses.size(); ++i5) {
-            ((IWorldAccess)this.worldAccesses.get(i5)).doNothingWithTileEntity(x, y, z, tileEntity);
+        for (IWorldAccess worldAccess : this.worldAccesses) {
+            worldAccess.doNothingWithTileEntity(x, y, z, tileEntity);
         }
     }
-    
-    public int countEntities(final Class clazz) {
+
+    public int countEntities(final Class<Entity> clazz) {
         int i2 = 0;
-        for (int i3 = 0; i3 < this.loadedEntityList.size(); ++i3) {
-            final Entity entity4 = (Entity)this.loadedEntityList.get(i3);
+        for (final Entity entity4 : this.loadedEntityList) {
             if (clazz.isAssignableFrom(entity4.getClass())) {
                 ++i2;
@@ -1430,16 +1443,16 @@
         return i2;
     }
-    
-    public void addLoadedEntities(final List list) {
-        this.loadedEntityList.addAll((Collection)list);
-        for (int i2 = 0; i2 < list.size(); ++i2) {
-            this.obtainEntitySkin((Entity)list.get(i2));
+
+    public void addLoadedEntities(final List<Entity> list) {
+        this.loadedEntityList.addAll(list);
+        for (Entity o : list) {
+            this.obtainEntitySkin(o);
         }
     }
-    
-    public void unloadEntities(final List list) {
-        this.unloadedEntityList.addAll((Collection)list);
+
+    public void unloadEntities(final List<Entity> list) {
+        this.unloadedEntityList.addAll(list);
     }
-    
+
     public boolean canBlockBePlacedAt(final int blockID, final int x, final int y, final int z, final boolean z5) {
         final int i6 = this.getBlockId(x, y, z);
@@ -1450,7 +1463,7 @@
             axisAlignedBB9 = null;
         }
-        return (axisAlignedBB9 == null || this.checkIfAABBIsClear(axisAlignedBB9)) && (block7 == Block.waterMoving || block7 == Block.waterStill || block7 == Block.lavaMoving || block7 == Block.lavaStill || block7 == Block.fire || block7 == Block.snow || (blockID > 0 && block7 == null && block8.canPlaceBlockAt(this, x, y, z)));
+        return (axisAlignedBB9 == null || this.checkIfAABBIsClear(axisAlignedBB9)) && (block7 == Block.WATER_MOVING || block7 == Block.WATER_STILL || block7 == Block.LAVA_MOVING || block7 == Block.LAVA_STILL || block7 == Block.FIRE || block7 == Block.SNOW || (blockID > 0 && block7 == null && block8.canPlaceBlockAt(this, x, y, z)));
     }
-    
+
     public PathEntity getPathToEntity(final Entity entity1, final Entity entity2, final float f3) {
         final int i4 = MathHelper.floor_double(entity1.posX);
@@ -1467,5 +1480,5 @@
         return new Pathfinder(chunkCache14).createEntityPathTo(entity1, entity2, f3);
     }
-    
+
     public PathEntity getEntityPathToXYZ(final Entity entity, final int x, final int y, final int z, final float f5) {
         final int i6 = MathHelper.floor_double(entity.posX);
@@ -1482,14 +1495,14 @@
         return new Pathfinder(chunkCache16).createEntityPathTo(entity, x, y, z, f5);
     }
-    
+
     public boolean isBlockProvidingPowerTo(final int x, final int y, final int z, final int i4) {
         final int i5 = this.getBlockId(x, y, z);
         return i5 != 0 && Block.blocksList[i5].isIndirectlyPoweringTo(this, x, y, z, i4);
     }
-    
+
     public boolean isBlockGettingPowered(final int i1, final int i2, final int i3) {
         return this.isBlockProvidingPowerTo(i1, i2 - 1, i3, 0) || this.isBlockProvidingPowerTo(i1, i2 + 1, i3, 1) || this.isBlockProvidingPowerTo(i1, i2, i3 - 1, 2) || this.isBlockProvidingPowerTo(i1, i2, i3 + 1, 3) || this.isBlockProvidingPowerTo(i1 - 1, i2, i3, 4) || this.isBlockProvidingPowerTo(i1 + 1, i2, i3, 5);
     }
-    
+
     public boolean isBlockIndirectlyProvidingPowerTo(final int x, final int y, final int z, final int i4) {
         if (this.isBlockNormalCube(x, y, z)) {
@@ -1499,27 +1512,26 @@
         return i5 != 0 && Block.blocksList[i5].isPoweringTo(this, x, y, z, i4);
     }
-    
+
     public boolean isBlockIndirectlyGettingPowered(final int x, final int y, final int z) {
         return this.isBlockIndirectlyProvidingPowerTo(x, y - 1, z, 0) || this.isBlockIndirectlyProvidingPowerTo(x, y + 1, z, 1) || this.isBlockIndirectlyProvidingPowerTo(x, y, z - 1, 2) || this.isBlockIndirectlyProvidingPowerTo(x, y, z + 1, 3) || this.isBlockIndirectlyProvidingPowerTo(x - 1, y, z, 4) || this.isBlockIndirectlyProvidingPowerTo(x + 1, y, z, 5);
     }
-    
+
     public EntityPlayer getClosestPlayerToEntity(final Entity entity, final double d2) {
         return this.getClosestPlayer(entity.posX, entity.posY, entity.posZ, d2);
     }
-    
+
     public EntityPlayer getClosestPlayer(final double d1, final double d3, final double d5, final double d7) {
         double d8 = -1.0;
         EntityPlayer entityPlayer11 = null;
-        for (int i12 = 0; i12 < this.playerEntities.size(); ++i12) {
-            final EntityPlayer entityPlayer12 = (EntityPlayer)this.playerEntities.get(i12);
-            final double d9 = entityPlayer12.getDistanceSq(d1, d3, d5);
+        for (EntityPlayer playerEntity : this.playerEntities) {
+            final double d9 = playerEntity.getDistanceSq(d1, d3, d5);
             if ((d7 < 0.0 || d9 < d7 * d7) && (d8 == -1.0 || d9 < d8)) {
                 d8 = d9;
-                entityPlayer11 = entityPlayer12;
+                entityPlayer11 = playerEntity;
             }
         }
         return entityPlayer11;
     }
-    
+
     public byte[] getChunkData(final int i1, final int i2, final int i3, final int x, final int y, final int z) {
         final byte[] b7 = new byte[x * y * z * 5 / 2];
@@ -1560,9 +1572,9 @@
         return b7;
     }
-    
+
     public void checkSessionLock() {
         try {
             final File file1 = new File(this.saveDirectory, "session.lock");
-            final DataInputStream dataInputStream2 = new DataInputStream((InputStream)new FileInputStream(file1));
+            final DataInputStream dataInputStream2 = new DataInputStream(Files.newInputStream(file1.toPath()));
             try {
                 if (dataInputStream2.readLong() != this.lockTimestamp) {
