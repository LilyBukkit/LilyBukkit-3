import java.nio.file.*
import java.util.zip.*

import groovy.json.JsonSlurper

plugins {
    id "java"
}

group 'net.buj'
version '1.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(8)
    }
}

tasks.register("setupJDK") {
    doLast {
        Utils.java17path = null

        if (Utils.java17path == null) {
            def jdkpath = Paths.get(project.rootDir.toString(), "tools/jdk17")
            Utils.java17path = jdkpath.toAbsolutePath()
            if (!Files.exists(Paths.get(Utils.java17path))) {
                println "Downloading JDK17..."

                String url = Utils.getDownloadURL(
                    System.properties['os.arch'].replace("amd64", "x64"),
                    System.properties['os.name'].toLowerCase().split(" ")[0]
                )

                println "From url " + url

                if (url == null) throw new RuntimeException("Running Rosepad toolchain requires JDK 17. " +
                    "Set TOOLKIT_JAVA17 environment variable " +
                    "to your JDK 17 installation")
                Utils.fetch(url, Paths.get(project.rootDir.toString(), "tools/jdk17.tar.gz"))

                println "Unpacking JDK17..."

                try {
                    copy {
                        from(tarTree(Paths.get(project.rootDir.toString(), "tools/jdk17.tar.gz")))
                        into(Utils.java17path)
                    }
                } catch (Exception ignored) {
                    println "Error while unpacking JDK, ignoring"
                }

                Files.list(Files.list(Paths.get(project.rootDir.toString(), "tools/jdk17")).findAny().get()).forEach(e -> {
                    Files.move(e, Paths.get(Utils.java17path).resolve(e.fileName));
                })
            }
        }
    }
}

class Utils {
    static String java17path = null;

    private Utils() {}

    static String getDownloadURL(String arch, String os) { // No autocomplete :sad_face:
        def json$1 = new URL("https://api.github.com/repos/adoptium/temurin17-binaries/releases?per_page=1").getText()
        def js     = new JsonSlurper()
        def json   = js.parseText(json$1)[0].assets
        def name   = "OpenJDK17U-jdk_${arch}_${os}_".toString()

        for (def object : json) {
            if (!object.name.startsWith(name)) continue

            return object.browser_download_url
        }

        return null
    }

    static def fetch(String file, Path path) {
        if (new File(path.toString()).isFile()) return
        Path parent = path.parent
        Files.createDirectories(parent)
        Files.copy(new URL(file).openStream(), path, StandardCopyOption.REPLACE_EXISTING)
    }

    static def unzip(Path source, Path dest) {
        byte[] buffer = new byte[1024]
        ZipInputStream zis = new ZipInputStream(new FileInputStream(source.toAbsolutePath().normalize().toString()))
        ZipEntry zipEntry = zis.getNextEntry()
        while (zipEntry != null) {
            File newFile = new File(dest.toString(), zipEntry.name)
            if (zipEntry.isDirectory()) {
                if (!newFile.isDirectory() && !newFile.mkdirs()) {
                    throw new IOException("Failed to create directory " + newFile)
                }
            } else {
                // fix for Windows-created archives
                File parent = newFile.parentFile
                if (!parent.isDirectory() && !parent.mkdirs()) {
                    throw new IOException("Failed to create directory " + parent)
                }
                // write file content
                FileOutputStream fos = new FileOutputStream(newFile)
                int len = 0
                while ((len = zis.read(buffer)) > 0) {
                    fos.write(buffer, 0, len)
                }
                fos.close()
            }
            zipEntry = zis.getNextEntry()
        }
        zis.closeEntry()
        zis.close()
    }

    static def enigma(Path jar, Path source, Path dest, Path tiny2map) {
        new File(dest.toString()).mkdirs() // JIC directory does not exists
        Path jre = Paths.get(Utils.java17path.toString(), "bin", "java")

        List<String> command = new ArrayList<String>()
        command.add(jre.toAbsolutePath().normalize().toString())
        command.add("-jar")
        command.add(jar.toAbsolutePath().normalize().toString())
        command.add("decompile")
        command.add("procyon")
        command.add(source.toAbsolutePath().normalize().toString())
        command.add(dest.toAbsolutePath().normalize().toString())
        command.add(tiny2map.toAbsolutePath().normalize().toString())

        Process process = new ProcessBuilder(command).start()
        StreamGobbler out = new StreamGobbler(process.inputStream)
        StreamGobbler err = new StreamGobbler(process.errorStream)
        out.start()
        err.start()

        if (process.waitFor() != 0) {
            throw new RuntimeException("Failed to decompile source")
        }
    }

    static def decompile(Path jar, Path source, Path dest, Path tiny2map) {
        enigma(jar, source, dest, tiny2map)

        LoopFunction loop1 = (Path p) -> {}
        loop1 = (Path p) -> {
            File file = p.toFile()
            if (file.isDirectory()) {
                 for (String sf : file.list()) {
                     if (loop1(p.resolve(sf))) {
                         return true
                     }
                 }
            }
            else if (file.isFile()) {
                FileInputStream stream = new FileInputStream(file)
                Scanner scanner = new Scanner(stream)
                if (scanner.nextLine().startsWith("java.lang.ArrayIndexOutOfBoundsException")) {
                    stream.close()
                    scanner.close()
                    return true
                }
                while (scanner.hasNextLine()) {
                    String line = scanner.nextLine()
                    if (line.contains('throw new IllegalStateException("An error occurred while decompiling this method.");')) {
                        stream.close()
                        scanner.close()
                        return true
                    }
                }
                stream.close()
                scanner.close()
            }
            return false
        }
        if (!loop1(dest)) return

        Path fix = dest.parent.resolve(".java-tmp")
        rm(fix)

        LoopFunction2 loop2 = (Path p1, Path p2) -> {}
        loop2 = (Path p1, Path p2) -> {
             File file = p1.toFile()
             if (file.isDirectory()) {
                 for (String sf : file.list()) {
                     loop2(p1.resolve(sf), p2.resolve(sf))
                 }
             }
             else if (file.isFile() && loop1(p1)) {
                 cp(p2, p1)
             }
        }
        do {
            println "Detected damaged files, re-running enigma..."
            enigma(jar, source, fix, tiny2map)
            loop2(dest, fix)
            rm(fix)
        } while (loop1(dest))
    }

    static def tiny(Path jar, Path source, Path dest, Path tiny2map, String from, String to) {
        new File(dest.parent.toString()).mkdirs() // JIC directory does not exists
        Path jre = Paths.get(Utils.java17path.toString(), "bin", "java")

        List<String> command = new ArrayList<String>()
        command.add(jre.toAbsolutePath().normalize().toString())
        command.add("-jar")
        command.add(jar.toAbsolutePath().normalize().toString())
        command.add(source.toAbsolutePath().normalize().toString())
        command.add(dest.toAbsolutePath().normalize().toString())
        command.add(tiny2map.toAbsolutePath().normalize().toString())
        command.add(from)
        command.add(to)

        Process process = new ProcessBuilder(command).start()
        StreamGobbler out = new StreamGobbler(process.inputStream)
        StreamGobbler err = new StreamGobbler(process.errorStream)
        out.start()
        err.start()

        if (process.waitFor() != 0) {
            throw new RuntimeException("Failed to apply mappings")
        }
    }

    static def rm(Path path) {
        File file = new File(path.toString())
        if (file.isDirectory()) {
            for (File sf : file.listFiles()) {
                rm(sf.toPath())
            }
        }
        file.delete()
    }

    static def cp(Path source, Path dest) {
        File file = source.toFile()
        if (file.isDirectory()) {
            dest.toFile().mkdirs()
            for (String sf : file.list()) {
                cp(source.resolve(sf), dest.resolve(sf))
            }
        }
        else if (file.isFile()) {
            Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING)
        }
    }
}

class StreamGobbler extends Thread { // Stolen from a guy on stackoverflow
    InputStream is

    StreamGobbler(InputStream is) {
        this.is = is
    }

    void run() {
        try {
            InputStreamReader isr = new InputStreamReader(is)
            BufferedReader br = new BufferedReader(isr)
            String line = null
            while ((line = br.readLine()) != null)
                System.out.println(line)
        } catch (IOException ioe) {
            ioe.printStackTrace()
        }
    }
}

abstract class JarEarlyPatcher extends DefaultTask {

    @TaskAction
    def patchJars() {
        Utils.fetch(
                "https://github.com/AlphaVerUnofficialJars/LilypadServer/releases/download/v105/lilypad_server_v105.jar",
                Paths.get(project.rootDir.toString(), "jars", "lilypad_server_s.jar"),
        )

        Utils.decompile(
                Paths.get(project.rootDir.toString(), "tools", "enigma.jar"),
                Paths.get(project.rootDir.toString(), "jars", "lilypad_server_s.jar"),
                Paths.get(project.rootDir.toString(), "server/src/main/java"),
                Paths.get(project.rootDir.toString(), "mappings", "server_deobf.tiny"),
        )

        Path serverDefaultPkg = Paths.get(project.rootDir.toString(), "server/src/main/java")
        for (String file : serverDefaultPkg.toFile().list()) {
            if (!new File(serverDefaultPkg.toFile(), file).isFile()) continue
            FileReader reader = new FileReader(new File(serverDefaultPkg.toFile(), file))
            FileWriter writer = new FileWriter(new File(serverDefaultPkg.toFile(), "net/minecraft/src/" + file))
            Scanner scanner = new Scanner(reader)
            writer.write("package net.minecraft.src;\n\n")
            while (scanner.hasNextLine()) {
                writer.write(scanner.nextLine())
                writer.write("\n")
            }
            scanner.close()
            reader.close()
            writer.close()
            Files.deleteIfExists(Paths.get(serverDefaultPkg.toString(), file))
        }

        Utils.rm(Paths.get(project.rootDir.toString(), "server/src/orig"))
        Utils.cp(
                Paths.get(project.rootDir.toString(), "server/src/main/java"),
                Paths.get(project.rootDir.toString(), "server/src/orig/java"),
        )
    }
}

abstract class ObfuscateTask extends DefaultTask {

    @TaskAction
    def obfuscate() {
        Files.createDirectories(Paths.get(project.rootDir.toString(), "build"))
        Utils.tiny(
                Paths.get(project.rootDir.toString(), "tools", "tiny-remapper.jar"),
                Paths.get(project.rootDir.toString(), "server/build/libs/server-1.1-SNAPSHOT-all.jar"),
                Paths.get(project.rootDir.toString(), "build/RosepadServer.jar"),
                Paths.get(project.rootDir.toString(), "mappings/server_reobf.tiny"),
                "official",
                "named",
        )
    }
}

interface LoopFunction {
    boolean run(Path dir)
}

interface LoopFunction2 {
    void run(Path dir, Path dir2)
}

interface LoopFunction3 {
    void run(Path dir, String entry)
}

tasks.register("prepare", JarEarlyPatcher) {
    dependsOn "setupJDK"
}
tasks.register("obfuscate", ObfuscateTask) {
    dependsOn "setupJDK"
    dependsOn ":server:shadowJar"
}

subprojects {
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(8)
        }
    }
}
